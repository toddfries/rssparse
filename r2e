#!/usr/bin/perl

# Copyright (c) 2010 Todd T. Fries <todd@fries.net>
#
# Permission to use, copy, modify, and distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

use strict;
use warnings;

use XML::Atom::Feed;
use XML::Feed;
use XML::Feed::Enclosure;
use XML::Feed::Format::RSS;
use LWP::UserAgent;
use HTML::FormatText::WithImgLinks;
use Encode qw( encode decode );
use Date::Manip;
use POSIX qw(strftime);
use Digest::SHA qw/sha256_base64/;
use Data::Dumper;

use XML::RSS;
$XML::RSS::AUTO_ADD = 1; # force acceptance of extra namespaces

use Encode qw( encode decode );

use FDC::CleanText;

if (1) {
$XML::Feed::Format::RSS::PREFERRED_PARSER = "XML::RSS::LibXML";
}
$XML::Feed::MULTIPLE_ENCLOSURES=1;

use OpenBSD::Getopt;

our $opt_v = 0;
getopts('v');

my $verbose = $opt_v;

my $config_file = $ENV{'HOME'}."/.r2e.conf";
my %conf;
if (open(C, $config_file)) {
	while (<C>) {
		next if /^#/;
		last if /^END$/;
		my $line;
		chomp($line=$_);
		my ($var,$val) = split(/=/,$line,2);
		if ($verbose) {
			printf STDERR "conf{%s} = '%s'\n",$var,$val;
		}
		push @{$conf{$var}}, $val;
	}
	close(C);
} else {
	die "Failed to open config $config_file: $!";
}

if (!defined(${$conf{'XML'}}[0])) {
	die "Failed to find XML in config $config_file";
}


my $ua = LWP::UserAgent->new();
$ua->agent( "R2E/0.0 " . $ua->agent );
$ua->env_proxy();

if ($verbose) {
	$| = 1; # Enable autoflush, to help with ordered output/debugging
}
foreach my $URL (@{$conf{'XML'}}) {
	my $content;

	printf STDERR "Requesting %s\n",$URL;

	my $req = HTTP::Request->new(GET => $URL);

	my $res = $ua->request( $req );

	my $text = $res->content_ref;

	my $feed;
	$content = decode('utf-8', $$text);
	$feed = parsefeed($URL,$content);

	if (!defined($feed)) {
		$content = decode('utf-8', FDC::CleanText::recode($text));
		$feed = parsefeed($URL,$content);
		if (!defined($feed)) {
			$content = $$text;
			$feed = parsefeed($URL,$content);
		}
	}
	$content = undef;
	if (!defined($feed)) {
		printf STDERR "%s: !feed\n",$URL;
		next;
	}

	my ($site) = $URL =~ m@^(.*://?[^/]+)/@;
	my ($base) = $URL =~ m@^(.*://?.+)/@;

	my $i = 0;

	if (0) {
	if (defined($feed->{atom}->{elem})) {
		my $tmpfeed = $feed->convert('RSS', version => '2.0');
		$feed = $tmpfeed;
		$tmpfeed = undef;
	}
	}
	my $feedauthor = $feed->author();
	if (!($feedauthor =~ /\@/)) {
		$feedauthor = undef;
	}
	my $feedemail  = $feed->{rss}->{channel}->{dc}->{creator};
	my $feedsubject = $feed->{rss}->{channel}->{dc}->{subject};
	my $feedfromname = handletext($feed->language,$feed->title);
	my $recipient = "todd\@t41.fries.net";
	printf STDERR "  ";
	my $entrycount = 0;
	my ($total_count,$dl_count,$found_count,$ignore_count)=(0,0,0,0);
	if ($verbose) {
		print STDERR recurse_dump($feed);
		if (0) {
		if (defined($feed->{atom}->{elem})) {
			print STDERR recurse_dump($feed->convert('RSS', version => '2.0'));
		}
		}
	}
	for my $entry ($feed->entries) {
		$total_count++;
		if ($verbose) {
			printf STDERR "\n%d.",++$entrycount;
		} else {
			printf STDERR ".";
		}
		my $guid = $entry->id();
		if (!defined($guid)) {
			$guid = $entry->{entry}->{guid};
		}
		my $link = $entry->link();
		my $datetime = $entry->issued();
		$datetime->set_time_zone("US/Central");
		my $date = $datetime->strftime(
	    		"%a, %d %b %Y %H:%M:%S %z");

		
		my $itemfromname = $entry->author() || $entry->{entry}->{dc}->{creator};
		my $itemsubject = $entry->{entry}->{dc}->{subject} || $feedsubject;
		my $fromemail;
		if (defined($feedemail)) {
			$fromemail = $feedemail;
		} else {
			$fromemail = "r2e\@example.com";
		}
		my $fromname;
		if (defined($feedfromname) && length($feedfromname) > 0) {
			$fromname = $feedfromname;
			if ($feedfromname eq $itemfromname) {
				$itemfromname = "";
			}
		}
		if (defined($itemsubject) && length($itemsubject) > 0) {
			if (length($fromname) > 0) {
				$fromname .= "/";
			}
			$fromname .= $itemsubject;
		}
		if (defined($itemfromname) && length($itemfromname) > 0) {
			$itemfromname =~ s/[[:space:]][[:space:]]*/ /gs;
			$itemfromname =~ s/[[:space:]]*$//g;
			$fromname .= ": $itemfromname";
			if (defined($feedauthor) && $feedauthor ne $itemfromname) {
				$fromname .= ", $feedauthor";
			}
		}
		if (defined($fromname)) {
			$fromname .= " ";
		} else {
			$fromname = "";
		}
		$fromname =~ s/[[:space:]][[:space:]]*/ /gs;
		my $fromstr = sprintf "%s<%s>",$fromname,$fromemail;
		if ($verbose) {
			printf STDERR "from %s\n%d.",decode('utf-8',$fromstr),$entrycount;
		}
		my $body = $entry->content->body;

		# make browsing the result useful in a portable way
		$body =~ s@(href|src|data)="/@$1="$site/@gs;
		$body =~ s@(href|src|data)="(?!(http|ftp))@$1="$base/@gs;

		$body = handletext($feed->language,$body);

		my $title = $entry->title;
		#$title =~ s/^\s+(.*)\s+$//s;

		# !title = !save
		$title = "(untitled)" if ! defined($title);
		$title = handletext($feed->language,$title);

		$title =~ s/[[:space:]][[:space:]]*/ /gs;
		$title =~ s/^"(.*)"$/$1/g;
		if (compare($body,$title) && length($title) > 65) {
			$title = substr($title,0,55)."...";
		}
		if ($verbose) {
			printf STDERR "title %s\n%d.",encode('utf-8',$title),$entrycount;
			printf STDERR " body %s\n%d.",encode('utf-8',$body),$entrycount;
			printf STDERR " date %s\n%d.",$date,$entrycount;
			printf STDERR " guid %s\n%d.",encode('utf-8',$guid),$entrycount;
		}

		my $mailstr = "";
		eval {
		  $mailstr .= sprintf "From: %s\n",$fromstr;
		  $mailstr .= sprintf "To: %s\n",$recipient;
		  $mailstr .= sprintf "Subject: %s\n",encode('utf-8',$title);
		  $mailstr .= sprintf "Message-Id: <%s.%s\@r2e>\n", sha256_base64($guid), strftime("%s",gmtime);
		  $mailstr .= sprintf "Date: %s\n",$date;
		  $mailstr .= sprintf "User-Agent: r2e\n";

		  my @tags = $entry->tags();
		  if (@tags) {
			my $tags = "";
			foreach my $tag (@tags) {
				$tags .= "$tag,";
			}
			$tags =~ s/,$//;
			$mailstr .= sprintf "X-RSS-Tags: %s\n", $tags;
		  }
		  $mailstr .= sprintf "\n";
		  $mailstr .= sprintf "%s\n",$body;
		  $mailstr .= sprintf "\n";
		};
		if ($@) {
			printf STDERR "failed std mailstr ops: $@\n";
		}
		my %vars;
		eval {
			if (defined($link)) {
				$vars{'URL'} = $link;
			}
			if (defined($entry->{entry}->{enclosure})) {
				my @encs = $entry->enclosure;
				foreach my $enc (@encs) {
					push @{$vars{'ENC'}},$enc;
				}
			}
			$vars{'LOC'}=$entry->{'entry'}->{'http://www.georss.org/georss'}->{'point'};
			if (!defined($vars{'LOC'})) {
			    if (defined($entry->lat) && defined($entry->long)) {
				$vars{'LOC'} = $entry->lat." ".$entry->long;
			    }
			}
			#}
			$vars{'GUID'} = $guid;
		};
		if ($@) {
			printf STDERR "failed var assignments: $@\n";
		}
		my $maxlen = 0;
		foreach my $v (keys %vars) {
			my $len = length($v);
			if ($len > $maxlen) {
				$maxlen = $len;
			}
		}
		# three items first in a specific order, the rest after
		my @order = ('URL','ENC',keys %vars);
		foreach my $v (@order) {
			my $val = $vars{$v};
			if ($verbose) {
				printf STDERR "var{$v} = %s\n",$val || "undef";
			}
			if (!defined($val)) {
				next;
			}
			if (ref($val) eq "") {
				$mailstr .= sprintf "%${maxlen}s: %s\n",$v,$val unless length($vars{$v}) == 0;
			} elsif (ref($val) eq "ARRAY") {
				foreach my $a (@{$val}) {
					if (ref($a) eq "") {
						$mailstr .= sprintf "%${maxlen}s: %s\n",$v,$a unless length($a) == 0;
					} elsif (ref($a) eq "XML::Feed::Enclosure") {
						$mailstr .= sprintf "%${maxlen}s: %s\n",$v,$a->url unless length($a->url) == 0;
					}
				}
			} else {
				printf STDERR "%s: unhandled ENC type %s\n",ref($val);
			}
			$vars{$v} = undef;
		}
		if ($verbose) {
			print STDERR recurse_dump($entry);
		}
		$mailstr .= "\n";
		if ($verbose) {
			open(MAIL,">>/dev/stdout");
		} else {
			open(MAIL,">>/dev/stdout");
			#open(MAIL,"|/usr/sbin/sendmail $recipient");
		}
		printf MAIL "%s",encode('utf-8',$mailstr);
		close(MAIL);
		$i++;
	}
	printf STDERR "\n";
}

sub
parsefeed
{
	my ($URL,$content) = @_;
	my $feed;
	eval {
		$feed = XML::Feed->parse(\$content);
	};
	if ($@) {
		printf STDERR "%s: $@\n",$URL;
		if (defined(XML::Feed->errstr)) {
			printf STDERR "%s: %s\n",$URL,XML::Feed->errstr;
		}
		return undef;
	}
	if ($feed->author() =~ /\@/) {
		return $feed;
	}
	my $atom = XML::Atom::Feed->new(\$content);
	my $person = $atom->author();
	if (defined($person)) {
		$feed->{rss}->{channel}->{dc}->{creator} = $person->email();
	}
	return $feed;
}

=pod
if (0) {
my $rss;
printf STDERR "Retrieving %s\n",$url;
my $req = HTTP::Request->new(GET => $url);

# $req->push_header( 'If-None-Match', $etag );
# $req->push_header( 'If-Modified-Since', $modified );

my $res = $ua->request( $req );

my %hdrs;

if (!$res->is_success ) {
	die "Result !success for $url";
}
my $content = decode('utf-8',$res->content);

for my $hdr ( "ETag", "Last-Modified", "Content-Type" ) {
	my $val = $res->headers->header( $hdr );
	#printf "   %s: %s\n", $hdr, ( $val || "unset" );
	if ($val) {
		if ( $hdr eq "ETag" ) {
			$hdrs{$hdr} = $val;
			# save ETag
		} elsif ( $hdr eq "Last-Modified" ) {
			$hdrs{$hdr} = UnixDate($val,"%s");
		} else {
			$hdrs{$hdr} = $val;
		}
	}
}
$res = undef;

my $contenttype = $hdrs{"Content-Type"};
my $charset;
if ($contenttype =~ /\bcharset=([^ ;]+)/) {
		#printf "  Charset: %s\n",$1;
		$charset = $1;
} else {
		$charset = "UTF-8";
}
$contenttype =~ s/;.*$//;
#printf "  Content-Type: %s\n",$contenttype;
if ( $contenttype eq "text/html" ) {
	# REALLY?
	if ($content =~ /^<\?xml/ ) {
		$contenttype = "text/xml";
	}
}
#my $text_string = decode($charset,$content);
#$content = $text_string;
#$text_string = undef;
my $preparsed;
$content =~ s/&pound/\&amp;pound/gs;
$content =~ s/[[:space:]][[:space:]]*/ /gs;
# if Atom, switch to RSS
if ( $content =~ m@(http://purl.org/atom|xmlns=["']?http://www.w3.org/2005/Atom)@si ) {
	eval {
		$preparsed = atom_to_rss( $content, $url );
	};
	if ($@) {
		printf STDERR "Feed ($url): conversion to rss from atom failed! $@\n";
		next;
	}
}

# throw away everything before the first XML declaration so we
# can get a clean parse if at all possible
$content =~ s/^.*?(<\?xml)/$1/s;


printf STDERR "  Parsing RSS ";
if (!defined($preparsed)) {
	eval {
		$rss = XML::RSS->new( version => "1.0", encoding => $charset || 'UTF-8',
			encode_output => 1);
		if ($verbose) {
			printf STDERR "\n\n=----- Content-----=\n\n";
			printf STDERR "%s\n",$content;
		}
		if (!$rss->parse($content)) {
			my $err = "";
			$err = $@ if $@;
			$err .= " ($!)" if $! and $! ne "Success";
			$err ||= "unknown error";
			die "\nparser failed: $err.";
		}
	}
} else {
	$rss = $preparsed;
}

$content = undef;

eval {
	#printf "%s\n",$rss->{version};

	#my $channel = $rss->{channel};
	# enable if XML::RSS still borks on feed images w/out titles or
	#  no image tag
	# delete $rss->{image}->{url} if defined( $rss->{image} );

	# Cleanse

	if ( @{$rss->{items}}) {
		$feed->language = $charset;
		printf STDERR "charset %s lang %s\n",$charset,$rss->{channel}->{dc}->{language} || 'undef';
		printf STDERR "  %d items in %s\n",$#{$rss->{items}}+1,$url;
		handlerss($rss);
	}
}

}
=cut


sub
handletext
{
	my ($cset,$text) = @_;
	my $r = "";
	eval {
		my $tdebug = 0;
		if ($tdebug) {
			printf STDERR "Input : '%s'\n",$text;
		}
		$r = parse_to_text($cset,encode('UTF-8',$text));
		if ($tdebug) {
		foreach my $lang (('iso-8859-1','iso-8859-2','iso-8859-16',
				'ascii','ascii-ctrl','utf-8')) {
			printf STDERR "Output: '%s'(%s)\n",encode($lang,$r),$lang;
		}
		}
	};
	if ($@) {
		printf STDERR " .. parse_to_text failed! $@\n";
	}
	return $r; # encode('utf-8',$r);
}
sub
parse_to_text
{
	my ($rsscset,$text) = @_;

	my $f = HTML::FormatText::WithImgLinks->new($rsscset);
	$text = $f->parse($text);
	$f = undef;

	return $text;
}

sub
recurse_dump
{
	my ($item) = @_;
	my $d = Data::Dumper->new([$item]);
	$d->Purity(1);
	$d->Terse(0);
	$d->Deepcopy(1);
	$d->Indent(2);
	$d->Sortkeys(1);
	#$d->Deparse(1);
	return $d->Dump();
}
sub
recurse_types
{
	my ($str,$item) = @_;
	if (!defined($item)) {
		return sprintf("%s undef\n",$str);
	}
	my $type = ref($item);
	if ($type eq "") {
		return sprintf("%s Data('%s'[%dB])\n",$str,$item,length($item));
	}
	my $retstr = "";
	if ($type eq "HASH") {
		foreach my $hkey (keys %{$item}) {
			$retstr .= recurse_types("$str: $hkey =>",${$item}{$hkey});
		}
		return $retstr;
	}
	if ($type eq "ARRAY") {
		foreach my $subitem (@{$item}) {
			$retstr .= recurse_types("$str: (",$subitem);
		}
		return $retstr;
	}
	if ($type eq "REF") {
		$retstr .= recurse_types("$str: REF",$$item);
		return $retstr;
	}
	my %test = $item;
	if (keys %test) {
		foreach my $hkey (keys %test) {
			$retstr .= recurse_types("${str}"."::"."$hkey =>",$test{$hkey});
		}
		return $retstr;
	}
	$retstr .= "$str: unhandled type: $type\n";
	return $retstr;
}
sub
compare
{
	my ($str1,$str2) = @_;

	$str1 =~ s/[[:space:]][[:space:]]*/ /g;
	$str2 =~ s/[[:space:]][[:space:]]*/ /g;
	return ($str1 eq $str2);
}

1;
